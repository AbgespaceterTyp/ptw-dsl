/*
 * generated by Xtext 2.13.0
 */
package de.htwg.modellgetriebene.validation

import de.htwg.modellgetriebene.pixelTankWarDsl.Battlefield
import de.htwg.modellgetriebene.pixelTankWarDsl.Player
import org.eclipse.xtext.validation.Check
import de.htwg.modellgetriebene.pixelTankWarDsl.PixelTankWarDslPackage

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PixelTankWarDslValidator extends AbstractPixelTankWarDslValidator {
	
	public static val DUPLICATE_NAME = 'duplicateName'
	public static val DUPLICATE_COLOR = 'duplicateColor'
	public static val HEALTH_POINTS_BELOW_ONE = 'healthPointsBelowOne'
	public static val HEALTH_POINTS_TOO_HIGH = 'healthPointsTooHigh'
	public static val ACTION_POINTS_BELOW_ONE = 'actionPointsBelowOne'
	public static val ACTION_POINTS_TOO_HIGH = 'actionPointsTooHigh'
	public static val LOCATION_OUT_OF_BOUNDS = 'locationOutOfBounds'
	public static val DUPLICATE_LOCATION = 'duplicateLocation'
	//public static val AAAAA = 'Aaaaa'
	//public static val AAAAA = 'Aaaaa'

	
	public var Battlefield battlefield

	@Check
	def checkAndLoadBattlefield(Battlefield bf) {
		battlefield = bf
		
		// TODO Pruefung aller locations auf uniqueness
		val playersLocations = battlefield.players.players.map[p1 | return p1.location]
		val blocksLocations = battlefield.blocks.blocks.map[b1 | return b1.location]
		
		val allLocations = playersLocations.clone
		allLocations.addAll(blocksLocations)
		
	}

	@Check
	def checkPlayer(Player player) {
		battlefield.players.players
			.groupBy[name]
			.forEach[p1, p2| 
			if(player.name.equals(p1) && p2.size() > 1) { 
				error("Name should be unique", PixelTankWarDslPackage.Literals.PLAYER__NAME, DUPLICATE_NAME)	
			}
		];
		
		battlefield.players.players
			.groupBy[color]
			.forEach[p1, p2| 
			if(player.color.equals(p1) && p2.size() > 1) { 
				error("Color should be unique", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)	
			}
		];
		
		battlefield.players.players
			.forEach[p1| 
			if(player != p1 && player.location.XPosition === (p1.location.XPosition) && player.location.YPosition === (p1.location.YPosition)) { 
				error("Position should be unique", PixelTankWarDslPackage.Literals.PLAYER__LOCATION, DUPLICATE_LOCATION)
			}
		];
		
		
		
		if(player.healthPoints < 1) {
			error("Health points must not be below 1", PixelTankWarDslPackage.Literals.PLAYER__HEALTH_POINTS, HEALTH_POINTS_BELOW_ONE)	
		}
		
		if(player.healthPoints > 10) {
			warning("Health points should be between 1 and 10, otherwise the game takes a long time to finish", PixelTankWarDslPackage.Literals.PLAYER__HEALTH_POINTS, HEALTH_POINTS_TOO_HIGH)
		}
		
		if(player.actionPoints < 1) {
			error("Action points must not be below 1", PixelTankWarDslPackage.Literals.PLAYER__ACTION_POINTS, ACTION_POINTS_BELOW_ONE)
		}
		
		if(player.actionPoints > 10) {
			warning("Action points should be between 1 and 10, otherwise the game takes a long time to finish", PixelTankWarDslPackage.Literals.PLAYER__ACTION_POINTS, ACTION_POINTS_TOO_HIGH)	
		}
		
		if(player.location.XPosition === 0 || player.location.XPosition > battlefield.dimesion.width) {
			error("X-Position has to be greater than 0 and within the battlefields width dimension", PixelTankWarDslPackage.Literals.PLAYER__LOCATION, LOCATION_OUT_OF_BOUNDS)
		}
		
		if(player.location.YPosition === 0 || player.location.YPosition > battlefield.dimesion.height) {
			error("Y-Position has to be greater than 0 and within the battlefields height dimension", PixelTankWarDslPackage.Literals.PLAYER__LOCATION, LOCATION_OUT_OF_BOUNDS)
		}
		
		
	}
	
	@Check
	def check() {
		
	}


	/*			
	@Check
	def void checkColorIsNotAlreadyUsed(Battlefield bf) {
		while (bf. !== null) {
	        for (other : bf.players.play) {
	            if (f.name == other.name) {
	                error("Feature names have to be unique",
	                    DomainmodelPackage.Literals.FEATURE__NAME)
	                return
	            }
	        }
	        superEntity = superEntity.getSuperType();
	    }

		warning("Name warn", PixelTankWarDslPackage.Literals.PLAYER__NAME)

		var Color one 
		var Color two 
		var Color three
		var Color four

		if(bf.players.playerOne !== null) {
			one = bf.players.playerOne.color
		}
		if(bf.players.playerTwo !== null) {
			two = bf.players.playerTwo.color	
		}
		if(bf.players.playerThree !== null) {
			three = bf.players.playerThree.color
		}
		if(bf.players.playerFour !== null) {
			four = bf.players.playerFour.color
		}
		
		if(one !== null) {
			if(player.color === one) error("Color: " + one + " should not be used more than once", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)
		}
		
		if(two !== null) {
			if(player.color === two) error("Color: " + two + " should not be used more than once", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)
		}
		
		if(three !== null) {
			if(player.color === three) error("Color: " + three + " should not be used more than once", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)
		}
		
		if(four !== null) {
			if(player.color === four) error("Color: " + four + " should not be used more than once", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)
		}
		
	}
*/
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					PixelTankWarDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}	
}
