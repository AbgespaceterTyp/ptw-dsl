/*
 * generated by Xtext 2.13.0
 */
package de.htwg.modellgetriebene.validation

import de.htwg.modellgetriebene.pixelTankWarDsl.Battlefield
import de.htwg.modellgetriebene.pixelTankWarDsl.Player
import org.eclipse.xtext.validation.Check
import de.htwg.modellgetriebene.pixelTankWarDsl.PixelTankWarDslPackage
import java.util.Collection
import org.eclipse.emf.common.util.EList
import de.htwg.modellgetriebene.pixelTankWarDsl.Location
import java.util.List
import de.htwg.modellgetriebene.pixelTankWarDsl.Block

/**
 * This class contains custom validation rules. 
 *
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
class PixelTankWarDslValidator extends AbstractPixelTankWarDslValidator {
	
	public static val DUPLICATE_NAME = 'duplicateName'
	public static val DUPLICATE_COLOR = 'duplicateColor'
	public static val HEALTH_POINTS_BELOW_ONE = 'healthPointsBelowOne'
	public static val HEALTH_POINTS_TOO_HIGH = 'healthPointsTooHigh'
	public static val ACTION_POINTS_BELOW_ONE = 'actionPointsBelowOne'
	public static val ACTION_POINTS_TOO_HIGH = 'actionPointsTooHigh'
	public static val LOCATION_OUT_OF_BOUNDS = 'locationOutOfBounds'
	public static val DUPLICATE_LOCATION_PLAYER = 'duplicateLocationPlayer'
	public static val DUPLICATE_LOCATION_BLOCK = 'duplicateLocationBlock'
	//public static val AAAAA = 'Aaaaa'

	public var Battlefield battlefield

	@Check
	def checkAndLoadBattlefield(Battlefield bf) {
		battlefield = bf
	}

	@Check
	def checkPlayerNameIsUnique(Player player) {
		battlefield.players.players
			.groupBy[name]
			.forEach[p1, p2| 
			if(player.name.equals(p1) && p2.size() > 1) { 
				error("Name should be unique", PixelTankWarDslPackage.Literals.PLAYER__NAME, DUPLICATE_NAME)	
			}
		];
	}
	
	@Check
	def checkPlayerColorIsUnique(Player player) {
		battlefield.players.players
			.groupBy[color]
			.forEach[p1, p2| 
			if(player.color.equals(p1) && p2.size() > 1) { 
				error("Color should be unique", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)	
			}
		];
	}
	
	@Check
	def checkPlayersHaveNoOccupiedPosition(Player player) {
		var playersLocations = battlefield.players.players.map[p | p.location]
		var blocksLocations = battlefield.blocks.blocks.map[b | b.location]
		
		var locations = playersLocations + blocksLocations
		
		var locationOccurrences = locations
			.filter[location | 
			player.location.XPosition === (location.XPosition) && player.location.YPosition === (location.YPosition)
			].size() 			
		
		if(locationOccurrences > 1) {
			error("Position should be unique", PixelTankWarDslPackage.Literals.PLAYER__LOCATION, DUPLICATE_LOCATION_PLAYER)		
		}
	}
	
	@Check
	def checkBlocksHaveNoOccupiedPosition(Block block) {
		var playersLocations = battlefield.players.players.map[p | p.location]
		var blocksLocations = battlefield.blocks.blocks.map[b | b.location]
		
		var locations = playersLocations + blocksLocations
		
		var locationOccurrences = locations
			.filter[location | 
			block.location.XPosition === (location.XPosition) && block.location.YPosition === (location.YPosition)
			].size()
		
		if(locationOccurrences > 1) {
			error("Position should be unique", PixelTankWarDslPackage.Literals.BLOCK__LOCATION, DUPLICATE_LOCATION_BLOCK)		
		}
	}

	@Check
	def checkPlayerHealthPointsAreInRange(Player player) {
		if(player.healthPoints < 1) {
			error("Health points must not be below 1", PixelTankWarDslPackage.Literals.PLAYER__HEALTH_POINTS, HEALTH_POINTS_BELOW_ONE)	
		}
		
		if(player.healthPoints > 10) {
			warning("Health points should be between 1 and 10, otherwise the game takes a long time to finish", PixelTankWarDslPackage.Literals.PLAYER__HEALTH_POINTS, HEALTH_POINTS_TOO_HIGH)
		}
	}
	
	@Check
	def checkPlayerActionPointsAreInRange(Player player) {
		if(player.actionPoints < 1) {
			error("Action points must not be below 1", PixelTankWarDslPackage.Literals.PLAYER__ACTION_POINTS, ACTION_POINTS_BELOW_ONE)
		}
		
		if(player.actionPoints > 10) {
			warning("Action points should be between 1 and 10, otherwise the game takes a long time to finish", PixelTankWarDslPackage.Literals.PLAYER__ACTION_POINTS, ACTION_POINTS_TOO_HIGH)	
		}
	}
	
	@Check
	def checkPlayerPositionsAreInRange(Player player) {
		if(player.location.XPosition > battlefield.dimesion.width) {
			error("X-Position has to within the battlefields width dimension", PixelTankWarDslPackage.Literals.PLAYER__LOCATION, LOCATION_OUT_OF_BOUNDS)
		}
		
		if(player.location.YPosition > battlefield.dimesion.height) {
			error("Y-Position has to be within the battlefields height dimension", PixelTankWarDslPackage.Literals.PLAYER__LOCATION, LOCATION_OUT_OF_BOUNDS)
		}
	}
	
	@Check
	def checkBlockPositionsAreInRange(Block block) {
		if(block.location.XPosition > battlefield.dimesion.width) {
			error("X-Position has to within the battlefields width dimension", PixelTankWarDslPackage.Literals.BLOCK__LOCATION, LOCATION_OUT_OF_BOUNDS)
		}
		
		if(block.location.YPosition > battlefield.dimesion.height) {
			error("Y-Position has to be within the battlefields height dimension", PixelTankWarDslPackage.Literals.BLOCK__LOCATION, LOCATION_OUT_OF_BOUNDS)
		}
	}
	
	@Check
	def check() {
		
	}


	/*			
	@Check
	def void checkColorIsNotAlreadyUsed(Battlefield bf) {
		while (bf. !== null) {
	        for (other : bf.players.play) {
	            if (f.name == other.name) {
	                error("Feature names have to be unique",
	                    DomainmodelPackage.Literals.FEATURE__NAME)
	                return
	            }
	        }
	        superEntity = superEntity.getSuperType();
	    }

		warning("Name warn", PixelTankWarDslPackage.Literals.PLAYER__NAME)

		var Color one 
		var Color two 
		var Color three
		var Color four

		if(bf.players.playerOne !== null) {
			one = bf.players.playerOne.color
		}
		if(bf.players.playerTwo !== null) {
			two = bf.players.playerTwo.color	
		}
		if(bf.players.playerThree !== null) {
			three = bf.players.playerThree.color
		}
		if(bf.players.playerFour !== null) {
			four = bf.players.playerFour.color
		}
		
		if(one !== null) {
			if(player.color === one) error("Color: " + one + " should not be used more than once", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)
		}
		
		if(two !== null) {
			if(player.color === two) error("Color: " + two + " should not be used more than once", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)
		}
		
		if(three !== null) {
			if(player.color === three) error("Color: " + three + " should not be used more than once", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)
		}
		
		if(four !== null) {
			if(player.color === four) error("Color: " + four + " should not be used more than once", PixelTankWarDslPackage.Literals.PLAYER__COLOR, DUPLICATE_COLOR)
		}
		
	}
*/
//	@Check
//	def checkGreetingStartsWithCapital(Greeting greeting) {
//		if (!Character.isUpperCase(greeting.name.charAt(0))) {
//			warning('Name should start with a capital', 
//					PixelTankWarDslPackage.Literals.GREETING__NAME,
//					INVALID_NAME)
//		}
//	}	
}
